import json
import sqlite3
import os
from pathlib import Path
import re
from apps.authentication.models import Malware_Data
from apps import db

def malware_behavior(case_id, db_path) :
    output_dir = "malware_analysis_results"
    user_upload_folder = os.path.dirname(db_path)
    if not os.path.exists(os.path.join(user_upload_folder, output_dir)) :
        os.makedirs(os.path.join(user_upload_folder, output_dir))
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    tables_to_search = {
        "Edge_Chromium_Downloads": "Download_Source",
        "Chrome_Downloads": "Download_Source"
    }

    keys = list(tables_to_search.keys())    
    print(f"Processing {os.path.basename(db_path)}: {keys}")

    # 추가로 검색할 테이블과 해당 컬럼
    another_table_to_search = {
        "AutoRun_Items": ["File_Name"],
        "LogFile_Analysis": ["Current_File_Name", "Original_File_Name"],
        "LNK_Files": ["Linked_Path"],
        "MRU_Recent_Files_and_Folders": ["File_Folder_Name"],  # & 기호 제거
        "MRU_Opened_Saved_Files": ["File_Name"],  # / 기호 제거
        "Prefetch_Files_Windows_8_10": ["Application_Name"],  # 특수문자 제거
        "SRUM_Application_Resource_Usage": ["Application_Name"],
        "SRUM_Network_Usage": ["Application_Name"],
        "Shim_Cache": ["File_Name"],
        "Startup_Items": ["Path"],
        "Windows_Event_Logs": ["Event_Data"],
        "AmCache_File_Entries": ["Name"],
        "UserAssist": ["File_Name"],
        "Scheduled_Tasks": ["Actions"],
        "UsnJrnl": ["File_Name"]
    }

    # 데이터베이스의 모든 테이블 이름 가져오기
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    existing_tables = {row[0] for row in cursor.fetchall()}

    # 테이블 이름 매핑 생성
    table_mapping = {
        "MRU_Recent_Files_&_Folders": "MRU_Recent_Files_and_Folders",
        "MRU_Opened/Saved_Files": "MRU_Opened_Saved_Files",
        '"Prefetch_Files___Windows_8/10"': "Prefetch_Files_Windows_8_10"
    }

    # 각 테이블의 시간 컬럼 이름을 저장할 딕셔너리
    time_column_mapping = {
        "AutoRun_Items": "Registry_Key_Modified_Date/Time_-_UTC_(yyyy-mm-dd)",
        "LogFile_Analysis": "Event_Date/Time_-_UTC_(yyyy-mm-dd)",
        "LNK_Files": "Created_Date/Time_-_UTC_(yyyy-mm-dd)",
        "MRU_Recent_Files_and_Folders": "Registry_Key_Modified_Date/Time_-_UTC_(yyyy-mm-dd)",  # & 기호 제거
        "MRU_Opened_Saved_Files": "Registry_Key_Modified_Date/Time_-_UTC_(yyyy-mm-dd)",  # / 기호 제거
        "Prefetch_Files_Windows_8_10": ["4th_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "File_Created_Date/Time_-_UTC_(yyyy-mm-dd)", "7th_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "2nd_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "3rd_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "5th_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "6th_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "8th_Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)", "Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)"],  # 특수문자 제거
        "SRUM_Application_Resource_Usage": "Recorded_Timestamp_Date/Time_-_UTC_(yyyy-mm-dd)",
        "SRUM_Network_Usage": "Recorded_Timestamp_Date/Time_-_UTC_(yyyy-mm-dd)",
        "Shim_Cache": "Key_Last_Updated_Date/Time_-_UTC_(yyyy-mm-dd)",
        "Startup_Items": "Last_Modified_Date/Time_-_UTC_(yyyy-mm-dd)",
        "Windows_Event_Logs": "Created_Date/Time_-_UTC_(yyyy-mm-dd)",
        "AmCache_File_Entries": "Key_Last_Updated_Date/Time_-_UTC_(yyyy-mm-dd)",
        "UserAssist": "Last_Run_Date/Time_-_UTC_(yyyy-mm-dd)",
        "Scheduled_Tasks": "Created_Date/Time_-_Local_Time_(yyyy-mm-dd)",
        "UsnJrnl": "Timestamp_Date/Time_-_UTC_(yyyy-mm-dd)"
    }

    # Prefetch_Files_Windows_8_10의 시간 컬럼 처리
    prefetch_time_columns = time_column_mapping.get("Prefetch_Files_Windows_8_10", [])

    # 파일 이름 리스트 가져오기
    target_files = set()
    for table in keys:
        if table not in existing_tables:
            print(f"Skipping table {table}: does not exist.")
            continue
        try:
            cursor.execute(f"SELECT File_Name FROM {table};")
            rows = cursor.fetchall()
            for row in rows:
                if row[0]:  # 파일 이름이 존재하면 추가
                    target_files.add(row[0])
        except sqlite3.Error as e:
            print(f"Error accessing table {table}: {e}")

    # 타겟 파일 이름별 결과 저장용 딕셔너리
    grouped_results = {file_name: {} for file_name in target_files}

    # 각 타겟 파일에 대해 다른 테이블에서 관련 데이터 검색
    for target_file in target_files:
        for table, columns in another_table_to_search.items():
            # 실제 테이블 이름 찾기
            actual_table = table
            for old_name, new_name in table_mapping.items():
                if new_name == table:
                    actual_table = old_name
                    break

            if actual_table.strip('"') not in existing_tables:
                print(f"Skipping table {actual_table}: does not exist.")
                continue
            
            grouped_results[target_file][table] = []  # 결과 초기화
            try:
                # 각 테이블의 지정된 컬럼에서 데이터 가져오기
                for column in columns:
                    query = f"""
                    SELECT *
                    FROM {actual_table}
                    WHERE {column} LIKE '%{target_file}%';
                    """
                    cursor.execute(query)
                    rows = cursor.fetchall()

                    # 테이블의 컬럼 이름 가져오기
                    cursor.execute(f"PRAGMA table_info({actual_table});")
                    column_names = [col[1] for col in cursor.fetchall()]

                    # 타겟 파일 이름과 매칭되는 ROW 저장
                    for row in rows:
                        grouped_results[target_file][table].append(
                            dict(zip(column_names, row))
                        )

                # Prefetch_Files_Windows_8_10 테이블의 시간 컬럼 처리
                if table == "Prefetch_Files_Windows_8_10":
                    for time_column in prefetch_time_columns:
                        try:
                            query = f"""
                            SELECT {time_column}
                            FROM {actual_table}
                            WHERE Application_Name LIKE '%{target_file}%';
                            """
                            cursor.execute(query)
                            rows = cursor.fetchall()

                            # 시간값을 저장할 리스트
                            time_values = [row[0] for row in rows if row[0]]

                            # 가장 최근의 시간값 선택
                            if time_values:
                                latest_time = max(time_values)
                                grouped_results[target_file][table].append({
                                    "Latest_Time": latest_time
                                })
                        except sqlite3.Error as e:
                            print(f"Error accessing table {actual_table}: {e}")

            except sqlite3.Error as e:
                print(f"Error accessing table {actual_table}: {e}")

        # .zip 파일인 경우 file_content_datas 테이블 검색
        if target_file.lower().endswith('.zip') and 'file_content_datas' in existing_tables:
            try:
                query = """
                SELECT *
                FROM file_content_datas
                WHERE content LIKE ?;
                """
                cursor.execute(query, (f'%{target_file}%',))
                rows = cursor.fetchall()

                cursor.execute("PRAGMA table_info(file_content_datas);")
                column_names = [col[1] for col in cursor.fetchall()]

                grouped_results[target_file]['file_content_datas'] = [
                    dict(zip(column_names, row)) for row in rows
                ]

                for row_dict in grouped_results[target_file]['file_content_datas']:
                    hit_id = row_dict.get('hit_id')
                    if hit_id:
                        # Prefetch 테이블에서 Application_Name 가져오기
                        prefetch_query = """
                        SELECT Application_Name
                        FROM "Prefetch_Files___Windows_8/10"
                        WHERE hit_id = ?;
                        """
                        cursor.execute(prefetch_query, (hit_id,))
                        app_names = [row[0] for row in cursor.fetchall() if row[0]]

                        for app_name in app_names:
                            # LNK_Files에서 Accessed_Date/Time 가져오기
                            lnk_query = """
                            SELECT "Accessed_Date/Time_-_UTC_(yyyy-mm-dd)"
                            FROM LNK_Files 
                            WHERE Linked_Path LIKE ?
                            ORDER BY "Accessed_Date/Time_-_UTC_(yyyy-mm-dd)";
                            """
                            cursor.execute(lnk_query, (f'%{app_name}%',))
                            access_times = [row[0] for row in cursor.fetchall() if row[0]]

                            for access_time in access_times:
                                # LogFile_Analysis에서 Create 이벤트 찾기
                                log_query = """
                                SELECT *
                                FROM LogFile_Analysis
                                WHERE "Event_Date/Time_-_UTC_(yyyy-mm-dd)" > ?
                                AND File_Operation = 'Create'
                                AND (Current_File_Name LIKE '%.exe' OR Original_File_Name LIKE '%.exe')
                                ORDER BY "Event_Date/Time_-_UTC_(yyyy-mm-dd)"
                                LIMIT 5;
                                """
                                cursor.execute(log_query, (access_time,))
                                log_rows = cursor.fetchall()

                                cursor.execute("PRAGMA table_info(LogFile_Analysis);")
                                log_columns = [col[1] for col in cursor.fetchall()]

                                # 각 로그 행을 딕셔너리로 변환하고 시간 비교
                                filtered_rows = []
                                for row in log_rows:
                                    row_dict = dict(zip(log_columns, row))
                                    created_time = row_dict.get('Current_Created_Date/Time_-_UTC_(yyyy-mm-dd)')
                                    accessed_time = row_dict.get('Current_Accessed_Date/Time_-_UTC_(yyyy-mm-dd)')
                                    modified_time = row_dict.get('Current_Modified_Date/Time_-_UTC_(yyyy-mm-dd)')

                                    # 모든 시간값이 존재하는 경우에만 비교
                                    if all([created_time, accessed_time, modified_time]):
                                        # modified_time이 created_time과 accessed_time보다 과거인 경우만 포함
                                        if modified_time < created_time and modified_time < accessed_time:
                                            filtered_rows.append(row_dict)

                                grouped_results[target_file]['Related_Create_Events'] = filtered_rows

            except sqlite3.Error as e:
                print(f"Error accessing tables: {e}")

    # 각 다운로드 파일별로 Web Visits 데이터 가져오기
    for target_file in target_files:
        web_visits_results = []
        
        # 다운로드 시간 가져오기
        for table in keys:
            if table not in existing_tables:
                continue
                
            try:
                query = f'''
                SELECT "Start_Time_Date/Time_-_UTC_(yyyy-mm-dd)"
                FROM "{table}"
                WHERE File_Name = ?;
                '''
                cursor.execute(query, (target_file,))
                row = cursor.fetchone()
                
                if row and row[0]:  # 시간값이 존재하면
                    start_time = row[0]
                    
                    # 해당 브라우저의 Web Visits 테이블 선택
                    if table == "Edge_Chromium_Downloads" and "Edge_Chromium_Web_Visits" in existing_tables:
                        web_visit_table = "Edge_Chromium_Web_Visits"
                    elif table == "Chrome_Downloads" and "Chrome_Web_Visits" in existing_tables:
                        web_visit_table = "Chrome_Web_Visits"
                    else:
                        continue

                    # Web Visits 데이터 가져오기
                    try:
                        query = f'''
                        SELECT *
                        FROM "{web_visit_table}"
                        WHERE "Date_Visited_Date/Time_-_UTC_(yyyy-mm-dd)" < ?
                        ORDER BY "Date_Visited_Date/Time_-_UTC_(yyyy-mm-dd)" DESC
                        LIMIT 2;
                        '''
                        cursor.execute(query, (start_time,))
                        rows = cursor.fetchall()

                        cursor.execute(f'PRAGMA table_info("{web_visit_table}");')
                        column_names = [col[1] for col in cursor.fetchall()]

                        for row in rows:
                            web_visits_results.append(dict(zip(column_names, row)))
                            
                    except sqlite3.Error as e:
                        print(f"Error accessing table {web_visit_table}: {e}")
                        
            except sqlite3.Error as e:
                print(f"Error accessing table {table}: {e}")
                
        # 결과 저장
        grouped_results[target_file]['Web_Visits'] = web_visits_results

    # JSON으로 결과 저장
    db_name = os.path.splitext(os.path.basename(db_path))[0]
    output_file = os.path.join(user_upload_folder, output_dir, f"{db_name}_results.json")

    # 최종 결과를 저장할 리스트
    final_results = []

    # Event_ID에 대한 설명을 저장할 딕셔너리
    event_descriptions = {
        # 예시: 특정 Event_ID에 대한 설명
        4668: "보통 - 프로세스 생성",
        4689: "보통 - 프로세스 종료",
        7045: "보통 - 윈도우 서비스 추가",
        4663: "보통 - 파일 개체 핸들 조작",
        4660: "보통 - 파일 개체 삭제",
        4656: "보통 - 레지스트리 개체 핸들 요청",
        4657: "보통 - 레지스트리 값 변경",
        4658: "보통 - 레지스트리 개체 핸들 닫힘",
        10000: "보통 - 네트워크 연결",
        10001: "보통 - 네트워크 연결 해제",
        4688: "보통 - 새 프로세스 생성",
        4697: "보통 - 새 서비스 설치 감지",
        5140: "보통 - 네트워크 공유 액세스",
        5156: "보통 - Windows 방화벽 허용 연결",
        5157: "보통 - Windows 방화벽 차단 연결",
        4672: "보통 - 특권이 할당된 계정 로그온",
        4624: "보통 - 계정 로그온 성공",
        4625: "보통 - 로그온 실패",
        4698: "보통 - 스케줄 작업 생성",
        4699: "보통 - 스케줄 작업 삭제",
        4673: "위험 - 권한 사용 시도",
        4674: "위험 - 권한 상승 시도",
        1102: "위험 - 보안 로그 삭제",
        4616: "보통 - 시스템 시간 변경",
        40961: "위험 - LSASS 메모리 액세스",
        40962: "위험 - DLL 인젝션 감지",
        1000: "보통 - 응용 프로그램 오류",
        1116: "위험 - 악성코드 감지",
        1117: "위험 - 악성코드 제거"
        # 추가적인 Event_ID와 설명을 여기에 추가
    }

    # TTPs 매핑을 위한 딕셔너리
    ttp_mappings = {
        "Windows_Event_Logs": {
            "Event_Data": {
                "c0000005": "메모리영역 액세스 위반",
                # 추가적인 매핑을 여기에 추가
            }
        },
        # 다른 테이블과 컬럼에 대한 매핑을 여기에 추가
    }

    for target_file, data in grouped_results.items():
        web_visits = data.get('Web_Visits', [])
        print(f"Debug: Processing target_file: {target_file}, Web Visits: {web_visits}")

        # 압축 해제 여부 초기화
        unzipped = False

        # TTPs 결과를 저장할 리스트
        ttps_results = []

        # 압축 해제 파일을 포함하여 모든 파일을 최종 결과에 저장
        if any(visit and '_Mail_' in (visit.get('_TAG_', '') or '') for visit in web_visits) or unzipped:
            # Timestamp
            timestamp = min(visit["Date_Visited_Date/Time_-_UTC_(yyyy-mm-dd)"] for visit in web_visits if visit)
            print(f"Debug: Timestamp: {timestamp}")

            # Filename
            filename = target_file
            print(f"Debug: Filename: {filename}")

            # Browser
            browser = web_visits[0].get('artifact_name', '').split(' ')[0] if web_visits else 'Unknown'
            print(f"Debug: Browser: {browser}")

            # Description_Connection
            description_connection = []
            description_list = []  # Event_ID에 대한 설명을 저장할 리스트
            hit_ids = []
            for table, entries in data.items():
                if table in another_table_to_search:
                    for entry in entries:
                        hit_id = entry.get('hit_id', 'N/A')
                        print(f"Debug: Table: {table}, Hit ID: {hit_id}")
                        hit_ids.append(hit_id)
                        # TTPs 매핑 확인
                        if table in ttp_mappings:
                            for column, patterns in ttp_mappings[table].items():
                                column_value = entry.get(column, '')
                                for pattern, ttp_text in patterns.items():
                                    if pattern in column_value:
                                        ttps_results.append(f"{hit_id}: {ttp_text}")

                        # 시간값 추출
                        time_column = time_column_mapping.get(table, 'N/A')
                        time_value = entry.get(time_column, 'N/A')
                        print(f"Debug: Time Column: {time_column}, Time Value: {time_value}")

                        if table == "SRUM_Application_Resource_Usage":
                            description_list.append("보통 - 애플리케이션 리소스 사용")
                        if table == "SRUM_Network_Usage":
                            description_list.append("위험 - 네트워크 사용")

                        # Windows_Event_Logs 테이블의 경우 Event_ID 추가
                        if table == "Windows_Event_Logs":
                            event_id = int(entry.get('Event_ID', 'N/A'))
                            event_data = entry.get('Event_Data', '')

                            # 특정 Event_ID에 대해 Event_Data를 기반으로 조건에 맞는 텍스트 추가
                            if event_id == 1000 and "<Data>c0000005" in event_data:
                                description_list.append(f"{event_descriptions[event_id]} - 메모리영역 액세스 위반")
                            # if event_id == 1116 and  in event_data:
                            #     description_list.append(f"{event_descriptions[event_id]} - 메모리영역 액세스 위반")
                            
                            description_connection.append(f"{table}: {hit_id}, {time_value}, Event_ID: {event_id}")
                            
                            # Event_ID에 대한 설명 추가
                            if event_id in event_descriptions:
                                description_list.append(event_descriptions[event_id])
                        else:
                            description_connection.append(f"{table}: {hit_id}, {time_value}")

                        # 압축 해제 여부 확인
                        if entry.get('Unzipped', False):
                            unzipped = True

            # Timeline
            # 날짜 및 시간 형식 탐지를 위한 정규 표현식
            datetime_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d{3})?'

            time_values = [
                entry.split(', ')[-1] for entry in description_connection
                if ', ' in entry and re.match(datetime_pattern, entry.split(', ')[-1])
            ]

            latest_time = max(time_values) if time_values else 'N/A'
            print(f"Debug: Latest Time: {latest_time}")

            timeline = f"{timestamp} ~ {latest_time}"
            print(f"Debug: Timeline: {timeline}")

            # 결과 추가
            final_results.append({
                "Timestamp": timestamp,
                "Filename": filename,
                "Browser": browser,
                "Description": description_list,  # Event_ID에 대한 설명 리스트 추가
                "Connection": description_connection,
                "Timeline": timeline,
                "Unzipped": unzipped,  # 압축 해제 여부 추가
                "TTPs": ttps_results,  # TTPs 결과 추가
                "hit_id" : hit_ids
            })
    with open(output_file, "w", encoding="utf-8") as json_file:
        json.dump(grouped_results, json_file, indent=4, ensure_ascii=False)

    # final_results를 별도의 JSON 파일로 저장
    final_results_file = os.path.join(user_upload_folder, output_dir, f"{db_name}_final_results.json")
    with open(final_results_file, "w", encoding="utf-8") as json_file:
        json.dump(final_results, json_file, indent=4, ensure_ascii=False)

    data = Malware_Data(case_id = case_id, results = final_results)
    db.session.add(data)
    db.session.commit()
